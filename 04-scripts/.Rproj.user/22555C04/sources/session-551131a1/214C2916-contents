---
title: "ctSEM Part I"
author: "Emorie Beck"
format: 
  html:
    code-tools: true
    code-copy: true
    code-line-numbers: true
    code-link: true
    theme: united
    highlight-style: tango
    df-print: paged
    code-fold: show
    cache: true
    toc: true
    toc-float: true
    self-contained: true
editor_options: 
  chunk_output_type: console
---

# Packages 

```{r}
library(psych)
library(knitr)
library(kableExtra)
library(lme4)
library(nlme)
library(rstan)
library(brms)
library(cmdstanr)
library(ctsemOMX)
library(ctsem)
library(patchwork)
library(broom)
library(broom.mixed)
library(ggquiver)
library(tidybayes)
library(plyr)
library(tidyverse)
```

# Functions 

## Custom Theme 
```{r}
my_theme <- function(){
  theme_bw() +
  theme(
    legend.position = "bottom"
    , legend.title = element_text(face = "bold", size = rel(1))
    , legend.text = element_text(face = "italic", size = rel(1))
    , axis.text = element_text(face = "bold", size = rel(1.1), color = "black")
    , axis.title = element_text(face = "bold", size = rel(1.2))
    , plot.title = element_text(face = "bold", size = rel(1.2), hjust = .5)
    , plot.subtitle = element_text(face = "italic", size = rel(1.2), hjust = .5)
    , strip.text = element_text(face = "bold", size = rel(1.1), color = "white")
    , strip.background = element_rect(fill = "black")
    )
}
```

# Data 
These data come from an unpublished paper looking at person and situation characteristics as part of a dynamic system in four samples. But we can use them in a simpler sense to just examine contingencies between situation characteristics and personality states. The following data represent EMA data from IPCS and concurrent data for agreeableness (personality state; POMP 0-10) and Adversity (situation characteristic; POMP 0-10).

## Data Functions 
```{r}
rescale_time <- function(x){
  x %>%
    arrange(Date) %>%
    mutate(time = difftime(Date, Date[1], unit = "hours")) %>%
    as.data.frame()
}

z_score <- function(x) (x - mean(x, na.rm = T))/sd(x, na.rm = T)
center <- function(x) x - mean(x, na.rm = T)
```

## Load and Clean Data 
```{r}
load("A-A-Adversity.RData")


d1 <- d %>% 
  select(SID, Date, p_value, s_value) %>%
  group_by(SID) %>%
  filter(n() >= 35) %>%
  nest() %>%
  ungroup() %>%
  mutate(data = map(data, rescale_time)) %>%
  unnest(data) %>%
  group_by(SID) %>%
  mutate(
    p_value_c = p_value - 5
    , s_value_c = s_value - 5
    , p_value_wpc = center(p_value)
    , s_value_wpc = center(s_value)
  ) %>%
  ungroup() %>%
  mutate(
    p_value_z = z_score(p_value)
    , s_value_z = z_score(s_value)
    ) %>%
  rename(id = SID); d1

d_ind <- d1 %>%
  filter(id == 100)
```

# Univariate 

$$
dP = (\beta_{p} \cdot P + \mu_{p})\cdot dt + \sigma_{p} \cdot dW
$$

## Helper Functions 

```{r}
# estimate attractor locations from posterior
loc_fun <- function(x){
  inter <- quantile(x, probs = c(.025, .5, .975))
  tibble(
    parameter = "location"
    , mean = mean(x)
    , sd = sd(x)
    , lower = inter[1]
    , mid = inter[2]
    , upper = inter[3]
    )
}

# add location to popmeans summary fit
fx_fun <- function(fit, par){
  samples <- fit$stanfit$transformedpars$popmeans
  colnames(samples) <- rownames(summary(fit)$popmeans)
  loc <- loc_fun(-1*samples[, paste("mu", par, sep = "_")]/samples[,paste("beta", par, sep = "_")])
  
  # save key params
  fx <- summary(fit)$popmeans %>%
    data.frame() %>%
    setNames(c("mean", "sd", "lower", "mid", "upper")) %>%
    rownames_to_column("parameter") %>%
    full_join(loc)
  return(fx)
}

plot_uni_1 <- function(sid, d, fit){
  
  # Posterior Coefficient Data Frame
  pars <- data.frame(fit$stanfit$transformedpars$popmeans) %>%
    sample_n(500) 
  
  old <- paste0("X", 1:ncol(pars)) 
  names(old) <- rownames(summary(fit)$popmeans)
  ord <- c("beta_p", "mu_p")
    
  pars <- pars %>% 
    select(all_of(old)) %>%
    select(all_of(ord))
  
  # Predictor Data Frame
  obs_data <- tibble(
    p_value = seq(min(d$p_value), max(d$p_value), .1)
    , intercept = 1
    )
  
  # Changes Prediction
  dt_pred <- data.frame( as.matrix(pars) %*% as.matrix(t(obs_data)) ) 
  
  dt_pred <- dt_pred %>%
    data.frame() %>%
    rownames_to_column("sample") %>%
    pivot_longer(
      cols = -sample
      , names_to = "t"
      , names_prefix = "X"
      , values_to = "change"
    ) %>%
    group_by(t) %>%
    median_qi(change) %>%
    select(-(.width:.interval)) %>%
    mutate(t = as.numeric(t))
  
  plot_data <- obs_data %>% 
    mutate(t = 1:n()) %>%
    full_join(dt_pred) %>%
    mutate(p_value = p_value )
  
  # plot_data <- plot_data %>% filter(er_goal %in% erg)
    xmini <- .25 # min(plot_data$p_value)
    ymini <- min(plot_data$.lower)
    ymaxi <- max(plot_data$.upper)
    if(abs(ymini) > abs(ymaxi)) ymaxi <- abs(ymini) else ymini <- -1*ymaxi
    p <- ggplot(
      plot_data
      , aes(x = p_value, y = change)
      ) +
      geom_hline(aes(yintercept = 0), linetype = "dashed", linewidth = 1) +
      geom_ribbon(
        aes(y = change, ymin = .lower, ymax = .upper)
        , alpha = 0.15, fill = "#00BA38"
        ) +
      geom_line(color = "#00BA38", size = 1) + 
      geom_line(
        aes(y = .lower)
        , color = "#00BA38", size = .25, linetype = "dashed"
      ) + 
      geom_line(
        aes(y = .upper)
        , color = "#00BA38", size = .25, linetype = "dashed"
      ) + 
      annotate(
        "segment", size = 1
        , arrow = arrow(type = "closed", length=unit(2, "mm"))
        , x = xmini, xend = xmini, y = .25, yend = ymaxi
        ) +
      annotate(
        "text"
        , label = "State is increasing"
        , x = xmini-.25, y = .25, angle = 90, hjust = 0
        ) +
      annotate(
        "segment", size = 1
        , arrow = arrow(type = "closed", length=unit(2, "mm"))
        , x = xmini, xend = xmini, y = -.25, yend = ymini
        ) +
      annotate(
        "text"
        , label = "State is decreasing"
        , x = xmini-.25, y = -.25, angle = 90, hjust = 1
        ) +
      # geom_jitter(, width = 0.3, height = 0.3) +
      labs(
        x = "Personality State"
        , y = "dE/dt"
        , title = "Simple Personality System"
        , subtitle = sid
        ) +
      my_theme() +
      xlim(0,10) + 
      # xlim(min(d$p_value)-.25, max(d$p_value)) + 
      ylim(ymini, ymaxi)
  return(p)
}
```


## N = 1 

### Personality State 
#### Sample Participant 
```{r}
m_ind <- mean(d_ind$p_value, na.rm = T)
cint_ind <- paste0("mu_p | 2.5*param+", m_ind)
model_uni_1 <- ctModel(
  type = "stanct"
  , manifestNames = c("p_value")                              # names of indicators in data
  , latentNames   = c("P")                                    # your choice of name for latent vars (i.e. process vars)
  , LAMBDA        = matrix(c(1), nrow = 1, byrow = T)         # diagonal matrix with loadings (1 for observed)
  , DRIFT         = matrix(c("beta_p"), nrow = 1, byrow = T)  # drift matrix; free, fix, or just name your terms
  , CINT          = matrix(c("mu_p"), nrow = 1, byrow = T)  # intercepts -- here our attractor
  , DIFFUSION     = matrix(c("sigma_p | 5*param"), nrow = 1, byrow = T) # innovation var/covar
  , T0MEANS       = matrix(c(m_ind)) # initial values to aid convergence
  , T0VAR         = matrix(c(0), nrow = 1, byrow = T)
  , MANIFESTMEANS = matrix(c(0), nrow = 1, byrow = T)         # manifest means - not really relevant for us
  # , MANIFESTVAR   = matrix(c(0), nrow = 1, byrow = T)         # manifest variance - not really relevant for us
  , id            = "id"                                      # participant ID in data frame
  , time          = "time"                                    # name of time in data frame
  )
# ctModelLatex(model_uni_1) # uh oh, can't vary across people if there's one person!
model_uni_1$pars$indvarying <- FALSE
# ctModelLatex(model_uni_1)

set.seed(6)
fit_uni_1 <- ctStanFit(
  data          = d_ind          # data for estimation
  , ctstanmodel = model_uni_1    # ctsem model from ctModel()
  , priors      = TRUE           # use priors in estimation; recommended for N = 1
  , optimize    = T
  , iter = 4000
)

summary(fit_uni_1)$popmeans
fx_fun(fit_uni_1, "p")

plot(fit_uni_1)
s
ctStanPostPredict(fit_uni_1)
plot_uni_1(100, d_ind, fit_uni_1)
```

#### Multiple Participants 

```{r}
uni_1_fun <- function(x, sid){
  m_ind <- mean(x$p_value, na.rm = T)
  cint_ind <- paste0("mu_p | 2.5*param+", m_ind)
  model_uni_1 <- ctModel(
    type = "stanct"
    , manifestNames = c("p_value")                          # names of indicators in data
    , latentNames   = c("P")                                    # your choice of name for latent vars (i.e. process vars)
    , LAMBDA        = matrix(c(1), nrow = 1, byrow = T)         # diagonal matrix with loadings (1 for observed)
    , DRIFT         = matrix(c("beta_p"), nrow = 1, byrow = T)  # drift matrix; free, fix, or just name your terms
    , CINT          = matrix(cint_ind, nrow = 1, byrow = T)    # intercepts -- here our attractor
    , DIFFUSION     = matrix(c("sigma_p | 2.5*param + 1.5"), nrow = 1, byrow = T) # innovation var/covar
    , T0MEANS       = matrix(m_ind)                             # initial values to aid convergence
    , T0VAR         = matrix(c(0), nrow = 1, byrow = T)
    , MANIFESTMEANS = matrix(c(0), nrow = 1, byrow = T)         # manifest means - not really relevant for us
    , MANIFESTVAR   = matrix(c(0), nrow = 1, byrow = T)         # manifest variance - not really relevant for us
    , id            = "id"                                     # participant ID in data frame
    , time          = "time"                                    # name of time in data frame
    )
  # ctModelLatex(model_uni_1) # uh oh, can't vary across people if there's one person!
  model_uni_1$pars$indvarying <- FALSE
  # ctModelLatex(model_uni_1)
  
  set.seed(5)
  fit <- ctStanFit(
    data          = x          # data for estimation
    , ctstanmodel = model_uni_1    # ctsem model from ctModel()
    , optimize    = T
    , priors      = TRUE           # use priors in estimation; recommended for N = 1
    , iter        = 2000
    , cores       = 1
  )
  save(fit, file = sprintf("uni-idio/models/p-%s.RData", sid))
  
  fx <- fx_fun(fit, "p")
  save(fx, file = sprintf("uni-idio/summaries/p-%s.RData", sid))
}

plan(multisession(workers = 12L))
d1 %>%
  mutate(SID2 = id) %>%
  group_by(SID2) %>%
  nest() %>%
  ungroup() %>%
  mutate(fit = future_map2(data, SID2, uni_1_fun, .progress = T))
closeAllConnections()
plan(sequential)
```

```{r}
loadRData <- function(file, obj){
  file <- sprintf("uni-idio/summaries/p-%s.RData", file)
  load(file)
  get(ls()[grepl(obj, ls())])
}

nested_sum <- d1 %>%
  group_by(id) %>%
  nest() %>%
  ungroup() %>%
  mutate(fx = map2(id, "fx", loadRData)) 

# histogram of parameters
nested_sum %>%
  select(-data) %>%
  unnest(fx) %>%
  # filter(sd < 10) %>%
  # mutate_at(vars(mean, lower, mid, upper), ~ifelse(parameter %in% c("mu_p", "location"), (.) + 5, .)) %>%
  ggplot(aes(x = mean)) + 
    geom_histogram(aes(fill = parameter), color = "black") + 
    facet_wrap(~parameter, nrow = 2, scales = "free") + 
    my_theme() +
    theme(legend.position = "none")

plot_call <- function(id, d){
  load(sprintf("uni-idio/models/p-%s.RData", sid))
  plot_uni_1(id, d, fit)
}

# change as outcome plots 
nested_sum <- nested_sum %>%
  mutate(p = map2(id, data, plot_call))
nested_sum$p[11:20]

uni_1_df <- nested_sum %>%
  select(id, fx) %>%
  unnest(fx) %>%
  # filter(sd < 5) %>%
  # mutate_at(vars(mean, lower, mid, upper), ~ifelse(parameter %in% c("mu_p", "location"), (.) + 5, .)) %>%
  filter(parameter %in% c("mu_p", "beta_p")) %>%
  select(id, parameter, mean) %>%
  pivot_wider(
    names_from = "parameter"
    , values_from = mean
  )

pms <- nested_sum %>%
  select(-fx) %>%
  unnest(data) %>%
  group_by(id) %>%
  summarize_at(vars(p_value, p_value_wpc), mean, na.rm = T) %>%
  ungroup() %>%
  mutate(p_value_pm = p_value + p_value_wpc) %>%
  select(-p_value, -p_value_wpc)

idio_seq <- function(d){
  rng <- range(d$p_value)
  tibble(p_value = seq(rng[1], rng[2], .1))
}

p_uni_1 <- uni_1_df %>%
  # crossing(
  #   p_value = seq(0,10, .5)
  # ) %>%
  # full_join(pms) %>%
  full_join(
    nested_sum %>%
      mutate(idio_seq = map(data, idio_seq)) %>%
      select(id, idio_seq) %>%
      unnest(idio_seq)
  ) %>%
  mutate(
    dp = mu_p + beta_p*p_value
    # , p_value = p_value_pm + p_value_wpc
    ) %>%
  ggplot(aes(x = p_value, y = dp)) + 
    geom_hline(
      aes(yintercept = 0)
      , linetype = "dashed"
      ) + 
    geom_line(
      aes(group = id)
      , color = "#00BA38"
      , linewidth = .25
      ) + 
    annotate(
      "segment", size = 1, x = 0, xend = 0, y = .25, yend = 10
      , arrow = arrow(type = "closed", length=unit(2, "mm"))
      ) +
    annotate(
      "text", x = -.25, y = 1, angle = 90, hjust = 0
      , label = "State is increasing"
      ) +
    annotate(
      "segment", size = 1, x = 0, xend = 0, y = -.25, yend = -10
      , arrow = arrow(type = "closed", length=unit(2, "mm"))
      ) +
    annotate(
      "text", x = -.25, y = -1, angle = 90, hjust = 1
      , label = "State is decreasing"
      ) +
    labs(
      x = "Personality State"
      , y = "dE/dt"
      , title = "Simple Personality System"
      , subtitle = "Idiographic Model Estimates"
      ) +
  ylim(-10, 10) + 
  my_theme()
p_uni_1
```

### Situation Characteristics 
```{r}
model_uni_1_s <- ctModel(
  type = "stanct"
  , manifestNames = c("s_value")                              # names of indicators in data
  , latentNames   = c("S")                                    # your choice of name for latent vars (i.e. process vars)
  , LAMBDA        = matrix(c(1), nrow = 1, byrow = T)         # diagonal matrix with loadings (1 for observed)
  , DRIFT         = matrix(c("beta_s"), nrow = 1, byrow = T)  # drift matrix; free, fix, or just name your terms
  , CINT          = matrix(c("mu_s"), nrow = 1, byrow = T)    # intercepts -- here our attractor
  , DIFFUSION     = matrix(c("sigma_s"), nrow = 1, byrow = T) # innovation var/covar
  , T0MEANS       = matrix(c(mean(d_ind$p_value, na.rm = T))) # initial values to aid convergence
  , MANIFESTMEANS = matrix(c(0), nrow = 1, byrow = T)         # manifest means - not really relevant for us
  , MANIFESTVAR   = matrix(c(0), nrow = 1, byrow = T)         # manifest variance - not really relevant for us
  , id            = "id"                                      # participant ID in data frame
  , time          = "time"                                    # name of time in data frame
  )
# ctModelLatex(model_uni_1_s) # uh oh, can't vary across people if there's one person!
model_uni_1_s$pars$indvarying <- FALSE
ctModelLatex(model_uni_1_s)

fit_uni_1_s <- ctStanFit(
  data          = d_ind          # data for estimation
  , ctstanmodel = model_uni_1_s  # ctsem model from ctModel()
  , priors      = TRUE           # use priors in estimation; recommended for N = 1
)

ctStanPostPredict(fit_uni_1_s)

summary(fit_uni_1_s)$popmeans
fx_fun(fit_uni_1_s, "s")

plot(fit_uni_1_s)
```

#### Multiple Participants 

```{r}
uni_1_s_fun <- function(x, sid){
  m_ind <- mean(x$s_value, na.rm = T)
  cint_ind <- paste0("mu_s | 2.5*param+", m_ind)
  model_uni_1 <- ctModel(
    type = "stanct"
    , manifestNames = c("s_value")                          # names of indicators in data
    , latentNames   = c("S")                                    # your choice of name for latent vars (i.e. process vars)
    , LAMBDA        = matrix(c(1), nrow = 1, byrow = T)         # diagonal matrix with loadings (1 for observed)
    , DRIFT         = matrix(c("beta_s"), nrow = 1, byrow = T)  # drift matrix; free, fix, or just name your terms
    , CINT          = matrix(cint_ind, nrow = 1, byrow = T)    # intercepts -- here our attractor
    , DIFFUSION     = matrix(c("sigma_s | 2.5*param + 1.5"), nrow = 1, byrow = T) # innovation var/covar
    , T0MEANS       = matrix(m_ind)                             # initial values to aid convergence
    , T0VAR         = matrix(c(0), nrow = 1, byrow = T)
    , MANIFESTMEANS = matrix(c(0), nrow = 1, byrow = T)         # manifest means - not really relevant for us
    , MANIFESTVAR   = matrix(c(0), nrow = 1, byrow = T)         # manifest variance - not really relevant for us
    , id            = "id"                                     # participant ID in data frame
    , time          = "time"                                    # name of time in data frame
    )
  # ctModelLatex(model_uni_1) # uh oh, can't vary across people if there's one person!
  model_uni_1$pars$indvarying <- FALSE
  # ctModelLatex(model_uni_1)
  
  set.seed(5)
  fit <- ctStanFit(
    data          = x          # data for estimation
    , ctstanmodel = model_uni_1    # ctsem model from ctModel()
    , optimize    = T
    , priors      = TRUE           # use priors in estimation; recommended for N = 1
    , iter        = 2000
    , cores       = 1
  )
  save(fit, file = sprintf("uni-idio/models/s-%s.RData", sid))
  
  fx <- fx_fun(fit, "s")
  save(fx, file = sprintf("uni-idio/summaries/s-%s.RData", sid))
}

plan(multisession(workers = 8L))
d1 %>%
  mutate(SID2 = id) %>%
  group_by(SID2) %>%
  nest() %>%
  ungroup() %>%
  mutate(fit = future_map2(data, SID2, possibly(uni_1_s_fun, NA_real_), .progress = T))
closeAllConnections()
plan(sequential)
```

```{r}
loadRData <- function(file, obj){
  file <- sprintf("uni-idio/summaries/s-%s.RData", file)
  load(file)
  get(ls()[grepl(obj, ls())])
}

nested_s_sum <- d1 %>%
  group_by(id) %>%
  nest() %>%
  ungroup() %>%
  mutate(fx = map2(id, "fx", loadRData)) 

# histogram of parameters
nested_s_sum %>%
  select(-data) %>%
  unnest(fx) %>%
  # filter(sd < 5) %>%
  # mutate_at(vars(mean, lower, mid, upper), ~ifelse(parameter %in% c("mu_p", "location"), (.) + 5, .)) %>%
  ggplot(aes(x = mean)) + 
    geom_histogram(aes(fill = parameter), color = "black") + 
    facet_wrap(~parameter, nrow = 2, scales = "free") + 
    my_theme() +
    theme(legend.position = "none")

plot_call <- function(id, d){
  load(sprintf("uni-idio/models/p-%s.RData", sid))
  plot_uni_1(id, d, fit)
}

# change as outcome plots 
nested_s_sum <- nested_s_sum %>%
  mutate(p = map2(id, data, plot_call))
nested_s_sum$p[11:20]

uni_1_df <- nested_s_sum %>%
  select(id, fx) %>%
  unnest(fx) %>%
  # filter(sd < 5) %>%
  # mutate_at(vars(mean, lower, mid, upper), ~ifelse(parameter %in% c("mu_p", "location"), (.) + 5, .)) %>%
  filter(parameter %in% c("mu_s", "beta_s")) %>%
  select(id, parameter, mean) %>%
  pivot_wider(
    names_from = "parameter"
    , values_from = mean
  )

pms <- nested_s_sum %>%
  select(-fx) %>%
  unnest(data) %>%
  group_by(id) %>%
  summarize_at(vars(s_value, s_value_wpc), mean, na.rm = T) %>%
  ungroup() %>%
  mutate(s_value_pm = s_value + s_value_wpc) %>%
  select(-s_value, -s_value_wpc)

idio_seq <- function(d){
  rng <- range(d$s_value)
  tibble(s_value = seq(rng[1], rng[2], .1))
}

p_s_uni_1 <- uni_1_df %>%
  # crossing(
  #   p_value = seq(0,10, .5)
  # ) %>%
  # full_join(pms) %>%
  full_join(
    nested_s_sum %>%
      mutate(idio_seq = map(data, idio_seq)) %>%
      select(id, idio_seq) %>%
      unnest(idio_seq)
  ) %>%
  mutate(
    ds = mu_s + beta_s*s_value
    # , p_value = p_value_pm + p_value_wpc
    ) %>%
  ggplot(aes(x = s_value, y = ds)) + 
    geom_hline(
      aes(yintercept = 0)
      , linetype = "dashed"
      ) + 
    geom_line(
      aes(group = id)
      , color = "#00BA38"
      , linewidth = .25
      ) + 
    annotate(
      "segment", size = 1, x = 0, xend = 0, y = .25, yend = 10
      , arrow = arrow(type = "closed", length=unit(2, "mm"))
      ) +
    annotate(
      "text", x = -.25, y = 1, angle = 90, hjust = 0
      , label = "State is increasing"
      ) +
    annotate(
      "segment", size = 1, x = 0, xend = 0, y = -.25, yend = -10
      , arrow = arrow(type = "closed", length=unit(2, "mm"))
      ) +
    annotate(
      "text", x = -.25, y = -1, angle = 90, hjust = 1
      , label = "State is decreasing"
      ) +
    labs(
      x = "Situation Characteristic"
      , y = "dE/dt"
      , title = "Simple Situation Characteristic System"
      , subtitle = "Idiographic Model Estimates"
      ) +
  ylim(-10, 10) + 
  my_theme()
p_s_uni_1
```


## Multilevel 
### Personality State

```{r}
m_pop <- mean(d1$p_value, na.rm = T)
cint_pop <- paste0("mu_p | 1*param+", m_pop)
model_uni_ml <- ctModel(
  type = "stanct"
  , manifestNames = c("p_value")                              # names of indicators in data
  , latentNames   = c("P")                                    # your choice of name for latent vars (i.e. process vars)
  , LAMBDA        = matrix(c(1), nrow = 1, byrow = T)         # diagonal matrix with loadings (1 for observed)
  , DRIFT         = matrix(c("beta_p"), nrow = 1, byrow = T)  # drift matrix; free, fix, or just name your terms
  , CINT          = matrix(c(cint_pop), nrow = 1, byrow = T)    # intercepts -- here our attractor
  , DIFFUSION     = matrix(c("sigma_p"), nrow = 1, byrow = T) # innovation var/covar
  , T0MEANS       = matrix(c(mean(d$p_value_c, na.rm = T)))     # initial values to aid convergence
  , MANIFESTMEANS = matrix(c(0), nrow = 1, byrow = T)         # manifest means - not really relevant for us
  , MANIFESTVAR   = matrix(c("mv_p"), nrow = 1, byrow = T)    # manifest variance - not really relevant for us  
  , id            = "id"                                      # participant ID in data frame
  , time          = "time"                                     # name of time in data frame
)

model_uni_ml$pars$indvarying[which(model_uni_ml$pars$param %in% c("beta_p","mu_p", "sigma_p"))] <- TRUE

ctModelLatex(model_uni_ml)

fit_uni_ml <- ctStanFit(
  data = d1
  , model_uni_ml
  , optimize = T
  , priors = T
  , cores = 10
)

summary(fit_uni_ml)$popmeans
fx_fun(fit_uni_ml, "p")

plot(fit_uni_ml)

ctStanDiscretePars(fit_uni_ml, plot = T, subjects = 1:25)

subs <- unique(d1$id)
IVEs <- ctStanSubjectPars(fit_uni_ml)
colnames(IVEs) <- subs
hist(IVEs[,,"beta_p"])
hist(IVEs[,,"mu_p"], breaks = 30)
uni_ml_df <- IVEs[,,c("mu_p", "beta_p")] %>% 
  data.frame() %>%
  rownames_to_column("id")

p_uni_ml <- uni_ml_df %>%
  crossing(
    p_value = seq(0,10,.05)# seq(-5,5, .5)
  ) %>%
  mutate(
    dp = mu_p + beta_p*p_value
    , p_value = p_value
    ) %>%
  ggplot(aes(x = p_value, y = dp)) + 
    geom_hline(
      aes(yintercept = 0)
      , linetype = "dashed"
      ) + 
    geom_line(
      aes(group = id)
      , color = "#00BA38"
      , linewidth = .25
      ) + 
    annotate(
      "segment", size = 1, x = 0, xend = 0, y = .25, yend = 10
      , arrow = arrow(type = "closed", length=unit(2, "mm"))
      ) +
    annotate(
      "text", x = -.25, y = 1, angle = 90, hjust = 0
      , label = "State is increasing"
      ) +
    annotate(
      "segment", size = 1, x = 0, xend = 0, y = -.25, yend = -10
      , arrow = arrow(type = "closed", length=unit(2, "mm"))
      ) +
    annotate(
      "text", x = -.25, y = -1, angle = 90, hjust = 1
      , label = "State is decreasing"
      ) +
    labs(
      x = "Personality State"
      , y = "dE/dt"
      , title = "Simple Personality System"
      , subtitle = "Multilevel Model Estimates"
      ) +
  ylim(-10, 10) + 
  my_theme()
p_uni_ml
```

### Situation Characteristic 
```{r}
mean(d1$s_value)
model_uni_ml_s <- ctModel(
  type = "stanct"
  , manifestNames = c("s_value")                              # names of indicators in data
  , latentNames   = c("S")                                    # your choice of name for latent vars (i.e. process vars)
  , LAMBDA        = matrix(c(1), nrow = 1, byrow = T)         # diagonal matrix with loadings (1 for observed)
  , DRIFT         = matrix(c("beta_s"), nrow = 1, byrow = T)  # drift matrix; free, fix, or just name your terms
  , CINT          = matrix(c("mu_s"), nrow = 1, byrow = T)    # intercepts -- here our attractor
  , DIFFUSION     = matrix(c("sigma_s"), nrow = 1, byrow = T) # innovation var/covar
  , T0MEANS       = matrix(c(mean(d$p_value, na.rm = T)))     # initial values to aid convergence
  , MANIFESTMEANS = matrix(c(0), nrow = 1, byrow = T)         # manifest means - not really relevant for us
  , MANIFESTVAR   = matrix(c("mv_s"), nrow = 1, byrow = T)    # manifest variance - not really relevant for us  
  , id            = "id"                                      # participant ID in data frame
  , time          = "time"                                     # name of time in data frame
)

model_uni_ml_s$pars$indvarying[which(model_uni_ml_s$pars$param %in% c("beta_s","mu_s", "sigma_s"))] <- TRUE

# ctModelLatex(model_uni_ml_s)

fit_uni_ml_s <- ctStanFit(
  data = d1
  , model_uni_ml_s
  , optimize = T
  , priors = T
  , cores = 10
)

summary(fit_uni_ml_s)$popmeans
fx_fun(fit_uni_ml_s, "s")

plot(fit_uni_ml_s)

ctStanDiscretePars(fit_uni_ml_s, plot = T, subjects = 1:20)

subs <- unique(d1$id)
IVEs <- ctStanSubjectPars(fit_uni_ml_s)
colnames(IVEs) <- subs
hist(IVEs[,,"beta_s"])
hist(IVEs[,,"mu_s"], breaks = 30)

uni_ml_s_df <- IVEs[,,c("mu_s", "beta_s")] %>% 
  data.frame() %>%
  rownames_to_column("id")

p_s_uni_ml <- uni_ml_s_df %>%
  crossing(
    s_value = seq(0,10,.05)# seq(-5,5, .5) 
  ) %>%
  mutate(
    ds = mu_s + beta_s*s_value
    , s_value = s_value
    ) %>%
  ggplot(aes(x = s_value, y = ds)) + 
    geom_hline(
      aes(yintercept = 0)
      , linetype = "dashed"
      ) + 
    geom_line(
      aes(group = id)
      , color = "#00BA38"
      , linewidth = .25
      ) + 
    annotate(
      "segment", size = 1, x = 0, xend = 0, y = .25, yend = 10
      , arrow = arrow(type = "closed", length=unit(2, "mm"))
      ) +
    annotate(
      "text", x = -.25, y = 1, angle = 90, hjust = 0
      , label = "State is increasing"
      ) +
    annotate(
      "segment", size = 1, x = 0, xend = 0, y = -.25, yend = -10
      , arrow = arrow(type = "closed", length=unit(2, "mm"))
      ) +
    annotate(
      "text", x = -.25, y = -1, angle = 90, hjust = 1
      , label = "State is decreasing"
      ) +
    labs(
      x = "Situation Characteristic"
      , y = "dE/dt"
      , title = "Simple Situation Characteristic System"
      , subtitle = "Multilevel Model Estimates"
      ) +
  ylim(-10, 10) + 
  my_theme()
p_s_uni_ml
```


## Comparisons
### Personality 
```{r}
p_uni_1 + p_s_uni_ml

plot_diff_fun <- function(x, par){
  ord <- x %>% 
    filter(type == "Idiographic") %>%
    arrange(type, desc(value)) %>%
    pull(id)
  x %>%
    mutate(id = factor(id, levels = ord)) %>%
    ggplot(aes(x = value, y = id)) + 
      geom_line(aes(group = id)) + 
      geom_point(aes(color = type)) +
      scale_color_manual(values = c("blue", "red")) + 
      labs(x = par, y = NULL, title = par) + 
      my_theme()
}

uni_shrink <- uni_1_df %>% 
  mutate(type = "Idiographic") %>%
  full_join(
    uni_ml_df %>%
      mutate(
        type = "Multilevel"
        , mu_p = mu_p
        )
  ) %>%
  pivot_longer(
    cols = c(-id, -type)
    , names_to = "par"
    , values_to = "value"
  ) %>%
  group_by(par) %>%
  nest() %>%
  ungroup() %>%
  mutate(p = map2(data, par, plot_diff_fun))

uni_shrink$p[[1]] + uni_shrink$p[[2]]
```

### Situations 

```{r}
p_s_uni_1 + p_s_uni_ml

plot_diff_fun <- function(x, par){
  ord <- x %>% 
    filter(type == "Idiographic") %>%
    arrange(type, desc(value)) %>%
    pull(id)
  x %>%
    mutate(id = factor(id, levels = ord)) %>%
    ggplot(aes(x = value, y = id)) + 
      geom_line(aes(group = id)) + 
      geom_point(aes(color = type)) +
      scale_color_manual(values = c("blue", "red")) + 
      labs(x = par, y = NULL, title = par) + 
      my_theme()
}

uni_shrink <- uni_1_df %>% 
  mutate(type = "Idiographic") %>%
  full_join(
    uni_ml_df %>%
      mutate(
        type = "Multilevel"
        , mu_p = mu_p
        )
  ) %>%
  pivot_longer(
    cols = c(-id, -type)
    , names_to = "par"
    , values_to = "value"
  ) %>%
  group_by(par) %>%
  nest() %>%
  ungroup() %>%
  mutate(p = map2(data, par, plot_diff_fun))

uni_shrink$p[[1]] + uni_shrink$p[[2]]
```

# Bivariate 
## Helper Functions 

```{r}
plot_bi_1 <- function(sid, d, fit){
  # load(sprintf("uni-idio/models/%s.RData", sid))
  
  # Posterior Coefficient Data Frame
  pars <- data.frame(fit$stanfit$transformedpars$popmeans) %>%
    sample_n(500) 
  
  old <- paste0("X", 1:ncol(pars)) 
  names(old) <- rownames(summary(fit)$popmeans)
  ord <- c("beta_p", "c_p", "c_s", "beta_s", "mu_p", "mu_s")
    
  pars <- pars %>% 
    select(all_of(old)) %>%
    select(all_of(ord))
  
  # Predictor Data Frame
  obs_data <- crossing(
    p_value = seq(min(d$p_value_c), max(d$p_value_c), .5)
    , s_value = seq(min(d$s_value_c), max(d$s_value_c), .5)
    )
  
  pred_fun <- function(x){
     drift <- matrix(as.matrix(x)[,1:4], byrow = T, nrow = 2)
     cint <- matrix(as.matrix(x)[,5:6], byrow = T, nrow = 1)
     pred <- t(unclass(mat) %*% as.matrix(t(obs_data))) 
     pred <- apply(pred, 1, function(x) x + cint)
     pred <- t(pred)
     pred <- obs_data %>% cbind(pred) %>%
       data.frame() %>%
       setNames(c("p_value", "s_value", "delta_p", "delta_s"))
     return(pred)
  }
  
 plot_data <-  pars %>% 
   data.frame() %>%
   rownames_to_column("t") %>%
   group_by(t) %>%
   nest() %>%
   ungroup() %>%
   mutate(pred = map(data, pred_fun)) %>%
   select(-data) %>%
   unnest(pred) %>%
   group_by(p_value, s_value) %>%
   median_qi(delta_p, delta_s) %>%
   as_tibble() 
 
  p <- plot_data %>% 
    mutate(col = sqrt(delta_p^2 + delta_s^2)) %>%
    ggplot(aes(x = p_value, y = s_value, u = delta_p, v = delta_s)) + 
    # geom_quiver(rescale = F)   +
    geom_quiver(aes(color = col), rescale = F)   +
    scale_color_gradient(low = "gray60", high = "black")+
    labs(
      x = "Agreeableness State Level"
      , y = "Adversity Situation Characteristic Level"
      , title = "Bivariate Person-Situation System"
      , subtitle = sid
      ) +
    my_theme() + 
    theme(legend.position = "none")
  return(p)
}
```

## N = 1

```{r}
model_bi_1 <- ctModel(
  type = "stanct"
  , manifestNames = c("p_value_c", "s_value_c")
  , latentNames   = c("P", "S")
  , LAMBDA        = diag(2)
  , DRIFT         = matrix(c("beta_p", "c_p"
                             , "c_s", "beta_s"), nrow = 2, byrow = T)
  , CINT          = matrix(c("mu_p", "mu_s"), nrow = 2, byrow = T)
  , MANIFESTMEANS = matrix(c(0, 0), nrow = 2)
  # , MANIFESTVAR   = matrix(c("mv_p", 0, 0, "mv_s"), nrow = 2, byrow = TRUE)
  , DIFFUSION     = matrix(c("sigma_p", 0
                             , 0, "sigma_s")
                              , nrow = 2, byrow = T)          # innovation var/covar
  , T0VAR = matrix(c("var_p", 0
                     , 0, "var_sit"), nrow = 2, byrow = TRUE)
  , id            = "id"
  , time          = "time"
  )
model_bi_1$pars$indvarying <- FALSE
ctModelLatex(model_bi_1)

fit_bi_1 <- ctStanFit(
  data = d_ind
  , model_bi_1
)

summary(fit_bi_1)$popmeans
plot(fit_bi_1)
plot_bi_1(100, d_ind, fit_bi_1)
```

## Multilevel 

```{r}
model_bi_ml <- ctModel(
  type = "stanct"
  , manifestNames = c("p_value_c", "s_value_c")
  , latentNames   = c("P", "S")
  , LAMBDA        = diag(2)
  , DRIFT         = matrix(c("beta_p", "c_p"
                             , "c_s", "beta_s"), nrow = 2, byrow = T)
  , CINT          = matrix(c("mu_p", "mu_s"), nrow = 2, byrow = T)
  , MANIFESTMEANS = matrix(c(0, 0), nrow = 2)
  , MANIFESTVAR   = matrix(c("mv_p", 0
                             , 0, "mv_s"), nrow = 2, byrow = TRUE)
  , DIFFUSION     = matrix(c("sigma_p", 0
                             , 0, "sigma_s")
                              , nrow = 2, byrow = T)          # innovation var/covar
  , T0VAR = matrix(c("var_p", 0, 0, "var_sit"), nrow = 2, byrow = TRUE)
  , id            = "id"
  , time          = "time"
  )
# model_bi_ml$pars$indvarying <- F
model_bi_ml$pars$indvarying[which(model_bi_ml$pars$param %in% c("beta_p", "c_p", "c_s", "beta_s", "mu_p", "mu_s", "sigma_p", "sigma_s"))] <- TRUE
ctModelLatex(model_bi_ml)

fit_bi_ml <- ctStanFit(
  datalong      = d1
  , ctstanmodel = model_bi_ml
  , optimize    = T
  , priors      = T
  , cores       = 10
)

summary(fit_bi_ml)$popmeans
plot(fit_bi_ml)

ctStanDiscretePars(fit_bi_ml, plot = T, subjects = 1:30)

subs <- unique(d1$id)
IVEs <- ctStanSubjectPars(fit_bi_ml)
colnames(IVEs) <- subs
hist(IVEs[,,"beta_p"])
hist(IVEs[,,"mu_p"], breaks = 30)
hist(IVEs[,,"beta_s"])
hist(IVEs[,,"mu_s"], breaks = 30)
```
